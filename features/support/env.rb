# frozen_string_literal: true

# IMPORTANT: This file is generated by cucumber-rails - edit at your own peril.
# It is recommended to regenerate this file in the future when you upgrade to a
# newer version of cucumber-rails. Consider adding your own code to a new file
# instead of editing this one. Cucumber will automatically load all features/**/*.rb
# files.

require 'cucumber/rails'
require 'selenium/webdriver'
require 'webdrivers'
Webdrivers.cache_time = 86_400

require 'simplecov'
SimpleCov.start 'rails'

def wait_for_render
  times = 3000

  while !all(:xpath, "//*[@id='waiting']").empty? && times > 0
    sleep(0.01)
    times -= 1
  end
end

Capybara.register_driver :headless_firefox do |app|
  profile = Selenium::WebDriver::Firefox::Profile.new
  client = Selenium::WebDriver::Remote::Http::Default.new
  client.timeout = 120 # instead of the default of 60s
  browser_options = Selenium::WebDriver::Firefox::Options.new
  browser_options.args << '--headless'
  Capybara::Selenium::Driver.new(
    app,
    browser: :firefox,
    profile:,
    http_client: client,
    options: browser_options
  )
end

Capybara.register_driver :firefox do |app|
  profile = Selenium::WebDriver::Firefox::Profile.new
  client = Selenium::WebDriver::Remote::Http::Default.new
  client.timeout = 120 # instead of the default of 60s
  browser_options = Selenium::WebDriver::Firefox::Options.new
  Capybara::Selenium::Driver.new(
    app,
    browser: :firefox,
    profile:,
    http_client: client,
    options: browser_options
  )
end

Capybara.register_driver(:remote_chrome) do |app|
  capabilities = Selenium::WebDriver::Remote::Capabilities.chrome(
    chromeOptions: { args: %w[disable-gpu] }
  )

  Capybara::Selenium::Driver.new(
    app,
    browser: :chrome,
    url: 'http://browser:4444/wd/hub'
    # desired_capabilities: capabilities
  )
end

Capybara.register_driver(:chrome) do |app|
  capabilities = Selenium::WebDriver::Remote::Capabilities.chrome(
    chromeOptions: { args: %w[disable-gpu] }
  )

  Capybara::Selenium::Driver.new(
    app,
    browser: :chrome
    # desired_capabilities: capabilities
  )
end

Capybara.javascript_driver = case ENV['DRIVER']
                             when 'docker'
                               Capybara.server_host = `hostname -s`.strip
                               Capybara.server_port = '31337'
                               Capybara.app_host = "http://#{Capybara.server_host}:#{Capybara.server_port}"
                               :remote_chrome
                             when 'chrome'
                               :chrome
                             when 'ff'
                               :firefox
                             when 'ff_h'
                               :headless_firefox
                             when 'safari'
                               :safari
                             when 'selenium'
                               :selenium
                             else # This will be the default for JavaScript
                               :selenium_chrome_headless
                             end
Capybara.default_driver = :rack_test
Cucumber::Rails::Database.autorun_database_cleaner = false

def loadData
  sql = File.read('db/test_db.sql')
  statements = sql.split(/;$/)
  statements.pop # remote empty line
  ActiveRecord::Base.transaction do
    statements.each do |statement|
      ActiveRecord::Base.connection.execute(statement)
    end
  end
end
# Capybara defaults to CSS3 selectors rather than XPath.
# If you'd prefer to use XPath, just uncomment this line and adjust any
# selectors in your step definitions to use the XPath syntax.
# Capybara.default_selector = :xpath

# By default, any exception happening in your Rails application will bubble up
# to Cucumber so that your scenario will fail. This is a different from how
# your application behaves in the production environment, where an error page will
# be rendered instead.
#
# Sometimes we want to override this default behaviour and allow Rails to rescue
# exceptions and display an error page (just like when the app is running in production).
# Typical scenarios where you want to do this is when you test your error pages.
# There are two ways to allow Rails to rescue exceptions:
#
# 1) Tag your scenario (or feature) with @allow-rescue
#
# 2) Set the value below to true. Beware that doing this globally is not
# recommended as it will mask a lot of errors for you!
#
ActionController::Base.allow_rescue = false

# Remove/comment out the lines below if your app doesn't have a database.
# For some databases (like MongoDB and CouchDB) you may need to use :truncation instead.
begin
  DatabaseCleaner.strategy = :transaction
rescue NameError
  raise 'You need to add database_cleaner to your Gemfile (in the :test group) if you wish to use it.'
end

# You may also want to configure DatabaseCleaner to use different strategies for certain features and scenarios.
# See the DatabaseCleaner documentation for details. Example:
#
#   Before('@no-txn,@selenium,@culerity,@celerity,@javascript') do
#     # { :except => [:widgets] } may not do what you expect here
#     # as Cucumber::Rails::Database.javascript_strategy overrides
#     # this setting.
#     DatabaseCleaner.strategy = :truncation
#   end
#
#   Before('~@no-txn', '~@selenium', '~@culerity', '~@celerity', '~@javascript') do
#     DatabaseCleaner.strategy = :transaction
#   end
#

Before '@javascript' do
  page.driver.browser.manage.window.resize_to(1024, 768)
  DatabaseCleaner.strategy = :truncation
end

# Possible values are :truncation and :transaction
# The :transaction strategy is faster, but might give you threading problems.
# See https://github.com/cucumber/cucumber-rails/blob/master/features/choose_javascript_database_strategy.feature
Cucumber::Rails::Database.javascript_strategy = :truncation

Before do
  EmailAddress::Config.setting(:host_validation, :syntax)
  loadData
  DatabaseCleaner.start
  Chronic.time_class = Time.zone
  travel_to DateTime.now.beginning_of_day
  @anon = false
end

After('@javascript') do |_scenario|
  DatabaseCleaner.clean
  loadData
  travel_back
  if :rack_test != Capybara.current_driver
    click_button 'resetTimeBtn'
  end
end

After('not @javascript') do |_scenario|
  DatabaseCleaner.clean
  travel_back
end

scenario_times = {}

World(ActiveJob::TestHelper)
Around() do |scenario, block|
  start = Time.zone.now
  perform_enqueued_jobs do
    block.call
  end
  scenario_times["#{scenario.location}::#{scenario.name}"] = Time.zone.now - start
end

at_exit do
  max_scenarios = scenario_times.size > 20 ? 20 : scenario_times.size
  total_time = scenario_times.values.inject(0) { |sum, x| sum + x }
  puts "Aggregate Testing Time: #{total_time}"
  puts "------------- Top #{max_scenarios} slowest scenarios -------------"
  sorted_times = scenario_times.sort { |a, b| b[1] <=> a[1] }
  sorted_times[0..max_scenarios - 1].each do |key, value|
    puts "#{value.round(2)}  #{key}"
  end
end
